---
layout: effect
title: Substrate
draft: true
---

<script type="module">
// Substrate Watercolor
// j.tarbell   June, 2004
// Albuquerque, New Mexico
// complexification.net

/*
TODO:
- color function instead of sampling?
- mask?

*/
import {normal} from "{{baseURL}}extend.js";
const canvas = document.querySelector("canvas");

const ctx = canvas.getContext("2d");
const W = canvas.width = 1920;
const H = canvas.height = 1080;

const COLORS = ['#000000', '#001000', '#100000', '#102028', '#302008',
  '#382810', '#383828', '#384030', '#484858', '#501000', '#505860', '#582800',
  '#585048', '#585838', '#586858', '#586868', '#603810', '#607070', '#685858',
  '#686870', '#687078', '#708080', '#787880', '#805800', '#905048', '#905818',
  '#906070', '#906848', '#983010', '#984008', '#986870', '#98A0B8', '#A03810',
  '#A05810', '#A07078', '#A07800', '#A07848', '#A08078', '#A09078', '#A0A0A8',
  '#A82818', '#A89070', '#A89848', '#A89868', '#A8A078', '#A8A880', '#A8B0A0',
  '#B08868', '#B09020', '#B09030', '#B0A098', '#B0A870', '#B0A890', '#B0B078',
  '#B0B098', '#B0B8B0', '#B0C0B8', '#B88868', '#B8B8A8', '#B8B8B0', '#C09888',
  '#C0A060', '#C0B078', '#C0B090', '#C0C090', '#C0C0B0', '#C8A078', '#C8B060',
  '#C8B078', '#C8B8A0', '#C8C098', '#C8C8B8', '#D0B078', '#D0B080', '#D0B0B0',
  '#D0B890', '#D0C058', '#D0C0A0', '#D0C8A0', '#D0C8A8', '#D0C8B0', '#D0D0C0',
  '#D8C070', '#D8C088', '#D8C0A0', '#D8C0A8', '#D8C0B0', '#D8C898', '#D8C8A0',
  '#D8C8B0', '#D8D0B0', '#E0A060', '#E0B080', '#E0B850', '#E0C858', '#E0C8A0',
  '#E0C8A8', '#E0D098', '#E0D0A0', '#E0D0B0', '#E0D8A0', '#E0D8B0', '#E0D8B8',
  '#E0E0B0', '#E0E0B8', '#E0E0C0', '#E8B828', '#E8B878', '#E8C078', '#E8C088',
  '#E8C848', '#E8C880', '#E8C898', '#E8D050', '#E8D078', '#E8D8A8', '#E8D8C0',
  '#E8D8C8', '#E8E080', '#E8E098', '#E8E0B0', '#E8E0C8', '#E8E8D8', '#E8F0C0',
  '#E8F0D8', '#E8F0E0', '#F0C868', '#F0C898', '#F0D098', '#F0D870', '#F0D890',
  '#F0D898', '#F0D8C0', '#F0D8D0', '#F0E080', '#F0E0B0', '#F0E0B8', '#F0E0C0',
  '#F0E8A0', '#F0E8B8', '#F0E8C0', '#F0E8C8', '#F0E8D0', '#F0E8D8', '#F0F0C0',
  '#F0F0C8', '#F0F0D0', '#F0F0E0', '#F0F8A8', '#F8B828', '#F8B888', '#F8E050',
  '#F8E070', '#F8E0A0', '#F8E0A8', '#F8E0B0', '#F8E0B8', '#F8E0C0', '#F8E0D8',
  '#F8E878', '#F8E8B8', '#F8E8C0', '#F8E8D0', '#F8E8E0', '#F8F0B8', '#F8F0C8',
  '#F8F0D0', '#F8F0D8', '#F8F8D0', '#F8F8F8', '#FF9828', '#FFC828', '#FFD028',
  '#FFD070', '#FFD0B8', '#FFD8A0', '#FFD8A8', '#FFD8B0', '#FFE078', '#FFE868',
  '#FFE878', '#FFE890', '#FFE898', '#FFE8B0', '#FFE8B8', '#FFE8C0', '#FFE8C8',
  '#FFE8D0', '#FFF098', '#FFF0A0', '#FFF0B8', '#FFF0C0', '#FFF0C8', '#FFF0D0',
  '#FFF0D8', '#FFF0E8', '#FFF0F8', '#FFF8B0', '#FFF8C0', '#FFF8C8', '#FFF8D0',
  '#FFF8D8', '#FFF8E0', '#FFFFC8', '#FFFFD0', '#FFFFD8'];
function getColor() {
  return COLORS[Math.floor(Math.random() * COLORS.length)];
}

function drawPoint(x, y, color, alpha = 1.0) {
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.fillRect(x, y, 1, 1);
}

const MAX_CRACKS = 128;
const MAX_TOTAL_CRACKS = 16384;
const cgrid = new Array(W * H);
const cracks = [];

const EMPTY = Infinity;
const INVALID = null;

let totalCracks = 0;

function get(x, y) {
  x = Math.floor(x);
  y = Math.floor(y);
  if (x < 0 || x >= W || y < 0 || y >= H) return INVALID;
  return cgrid[x + y * W];
}

function set(x, y, v) {
  x = Math.floor(x);
  y = Math.floor(y);
  if (x < 0 || x >= W || y < 0 || y >= H) return;
  cgrid[x + y * W] = v;
}

function step(pos, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);

  const dtX = (Math.floor(pos.x) + Math.sign(cos) - pos.x) / cos;
  const dtY = (Math.floor(pos.y) + Math.sign(sin) - pos.y) / sin;
  const t = Math.min(dtX, dtY);

  let x = pos.x + t * cos;
  let y = pos.y + t * sin;

  return {x, y};
}

class Crack {
  constructor(x, y, angle) {
    this.angle = angle;
    this.pos = step({x, y}, this.angle);

    this.color = getColor();
    this.mod = 0.5 * Math.random();
  }

  move() {
    // continue cracking
    this.pos = step(this.pos, this.angle);

    // draw sand painter
    this.regionColor();

    // draw black crack
    for (let i = 0 ; i < 2; ++i) {
      drawPoint(
        this.pos.x + 0.33 * normal(), this.pos.y + 0.33 * normal(), "#000", 1.0);
    }

    const v = get(this.pos.x, this.pos.y);

    if (v === INVALID) {
      return false;
    }

    if (v == EMPTY) {
      set(this.pos.x, this.pos.y, this.angle);
    } else if (Math.abs(v - this.angle) > 0.05) {
      return false;
    }

    return true;
  }

  regionColor() {
    let rx = this.pos.x;
    let ry = this.pos.y;

    let r = {...this.pos};
    while (true) {
      r = step(r, this.angle + Math.TAU / 4);
      const v = get(r.x, r.y);
      if (v === INVALID || v != EMPTY) break;
    }

    this.paintTo(r.x, r.y);
  }

  paintTo(x, y) {
    this.mod = Math.clamp(this.mod + 0.05 * normal(), 0, 1.0);

    const tx = this.pos.x + (x - this.pos.x) * this.mod;
    const ty = this.pos.y + (y - this.pos.y) * this.mod;

    const g = ctx.createLinearGradient(this.pos.x, this.pos.y, tx, ty);
    const S = 5;
    for (let i = 0; i < S; ++i) {
      const f = i / (S - 1);
      const a = 0.25 * ((1 - f) ** 0.25);
      g.addColorStop(f,
        this.color + Math.floor(256 * a).toString(16).padStart(2, '0'));
    }

    ctx.strokeStyle = g;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 1.0;
    ctx.beginPath();
    ctx.moveTo(this.pos.x, this.pos.y);
    ctx.lineTo(tx, ty);
    ctx.stroke();
    ctx.globalCompositeOperation = "source-over";
  }
}

function makeCrack() {
  if (cracks.length >= MAX_CRACKS) return;
  if (totalCracks >= MAX_TOTAL_CRACKS) return;

  let px = 0;
  let py = 0;

  let found = false;
  for (let i = 0; i < W * H; ++i) {
    px = Math.random() * W;
    py = Math.random() * H;
    if (get(px, py) != EMPTY) {
      found = true;
      break;
    }
  }
  if (!found) {
    console.log("timeout");
    return;
  }

  const dir = Math.sign(Math.random() - 0.5);
  const angle = get(px, py) + dir * ((Math.TAU / 4) + 0.05 * normal());

  cracks.push(new Crack(px, py, angle));
  totalCracks++;
}

function begin() {
  for (let i = 0; i < W * H; ++i) {
    cgrid[i] = EMPTY;
  }

  for (let k = 0; k < 16; ++k) {
    const i = Math.floor(Math.random() * W * H);
    cgrid[i] = Math.random() * Math.TAU;
  }

  totalCracks = 0;
  cracks.length = 0;

  for (let k = 0; k < 3; ++k) {
    makeCrack();
  }

  ctx.reset();
  ctx.fillStyle = "#FFF";
  ctx.fillRect(0, 0, W, H);
}

function frame() {
  for (let i = 0; i < 4; ++i) {
    cracks.filterIn(c => {
      if (!c.move()) {
        makeCrack();
        makeCrack();
        return false;
      }
      return true;
    });
  }

  requestAnimationFrame(frame);
}

begin();
frame();

</script>
