---
layout: effect
title: Substrate
draft: true
---

<script type="module">
// Substrate Watercolor
// j.tarbell   June, 2004
// Albuquerque, New Mexico
// complexification.net

import {normal, Color} from "{{baseURL}}/js/extend.js";
const canvas = document.querySelector("canvas");

const ctx = canvas.getContext("2d");
const W = canvas.width = 1920;
const H = canvas.height = 1080;

function step(pos, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);

  const dtX =
    cos != 0 ? (Math.floor(pos.x) + Math.sign(cos) - pos.x) / cos : Infinity;
  const dtY =
    sin != 0 ? (Math.floor(pos.y) + Math.sign(sin) - pos.y) / sin : Infinity;
  const t = Math.min(dtX, dtY);

  return {
    x: pos.x + t * cos,
    y: pos.y + t * sin
  };
}

const EMPTY = Infinity;
const INVALID = null;

class Substrate {
  constructor() {
    this.totalCracks = 0;
    this.maxTotalCracks = -1;
    this.maxCracks = 128;
    this.cracks = [];

    this.grid = new Array(W, H);
    for (let i = 0; i < W * H; ++i) {
      this.grid[i] = EMPTY;
    }

    this.colors = [];
    this.lineColor = '#000';

    this.angleVariance = 0.025;
  }

  clear(bgColor) {
    ctx.reset();
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, W, H);
  }

  begin({random = 0, start = 0, mask = null}) {
    if (mask !== null) {
      const add = mask.applyMask(this);
      for (const a of add) {
        this.newCrack(...a);
      }
    }

    let k = 0;
    while (k < random) {
      const x = Math.random() * W;
      const y = Math.random() * H;
      if (this.get(x, y) !== EMPTY) continue;

      this.set(x, y, Math.random() * Math.TAU);
      k++;
    }

    for (let k = 0; k < start; ++k) {
      ss.makeCrack();
    }
  }

  update() {
    this.cracks.filterIn(c => {
      if (!c.move()) {
        this.makeCrack();
        this.makeCrack();
        return false;
      }
      return true;
    });
    return this.cracks.length > 0;
  }

  makeCrack() {
    if (this.cracks.length >= this.maxCracks) return;
    if (this.maxTotalCracks > 0 && this.totalCracks >= this.maxTotalCracks) {
      return;
    }

    let px = 0;
    let py = 0;

    let found = false;
    for (let i = 0; i < W * H; ++i) {
      px = Math.random() * W;
      py = Math.random() * H;
      const p = this.get(px, py);
      if (p != EMPTY && p != INVALID) {
        found = true;
        break;
      }
    }
    if (!found) return;

    const dir = Math.sign(Math.random() - 0.5);
    const variance = this.angleVariance * normal();
    const angle = this.get(px, py) + dir * ((Math.TAU / 4) + variance);

    this.newCrack(px, py, angle);
  }

  newCrack(x, y, angle) {
    this.cracks.push(new Crack(this, x, y, angle));
    this.totalCracks++;
  }

  getColor() {
    if (this.colors === null) return null;
    return this.colors[Math.floor(Math.random() * this.colors.length)];
  }

  get(x, y) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (x < 0 || x >= W || y < 0 || y >= H) return INVALID;
    return this.grid[x + y * W];
  }

  set(x, y, v) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (x < 0 || x >= W || y < 0 || y >= H) return;
    this.grid[x + y * W] = v;
  }
}

class Crack {
  constructor(sub, x, y, angle) {
    this.sub = sub;
    this.angle = angle;
    this.pos = step({x, y}, this.angle);
    if (this.sub.get(this.pos.x, this.pos.y) === INVALID) {
      this.pos = null;
    }
    this.mod = 0.5 * Math.random();
    this.color = this.sub.getColor();
  }

  move() {
    if (this.pos === null) return false;
    this.pos = step(this.pos, this.angle);

    if (this.color !== null) {
      this.paintRegion();
    }

    for (let i = 0 ; i < 2; ++i) {
      ctx.fillStyle = this.sub.lineColor;
      ctx.fillRect(
        this.pos.x + 0.33 * normal(),
        this.pos.y + 0.33 * normal(),
        1, 1);
    }

    const v = this.sub.get(this.pos.x, this.pos.y);
    if (v === INVALID) {
      return false;
    }
    if (v == EMPTY) {
      this.sub.set(this.pos.x, this.pos.y, this.angle);
    } else if (Math.abs(v - this.angle) > 0.05) {
      return false;
    }

    return true;
  }

  paintRegion() {
    let rx = this.pos.x;
    let ry = this.pos.y;

    let r = {...this.pos};
    while (true) {
      r = step(r, this.angle + Math.TAU / 4);
      const v = this.sub.get(r.x, r.y);
      if (v === INVALID || v != EMPTY) break;
    }

    this.mod = Math.clamp(this.mod + 0.05 * normal(), 0, 1.0);

    const tx = this.pos.x + (r.x - this.pos.x) * this.mod;
    const ty = this.pos.y + (r.y - this.pos.y) * this.mod;

    const grad = ctx.createLinearGradient(this.pos.x, this.pos.y, tx, ty);
    const S = 5;
    for (let i = 0; i < S; ++i) {
      const f = i / (S - 1);
      const a = 0.25 * ((1 - f) ** 0.25);
      grad.addColorStop(f, this.color.alpha(a));
    }

    ctx.strokeStyle = grad;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.pos.x, this.pos.y);
    ctx.lineTo(tx, ty);
    ctx.stroke();
  }
}

class Mask {
  constructor() {
    this.ofc = new OffscreenCanvas(W, H);
    this.ctx = this.ofc.getContext("2d");
    this.ctx.reset();
    this.ctx.fillStyle = "#000";
    this.ctx.fillRect(0, 0, W, H);
    this.ctx.fillStyle = "#FFF";

    this.toAdd = [];
  }

  applyMask(ss) {
    const im = this.ctx.getImageData(0, 0, W, H).data;

    for (let y = 0; y < H; ++y) {
      for (let x = 0; x < W; ++x) {
        const p = (x + y * W) * 4;
        const c = im[p];
        ss.set(x, y, c == 0 ? INVALID : EMPTY);
      }
    }
    return this.toAdd;
  }

  line(x0, y0, x1, y1) {
    const ang = Math.atan2(y1 - y0, x1 - x0);
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
    this.toAdd.push([x0, y0, ang]);
  }

  poly(...points) {
    this.ctx.fillStyle = "#FFF";
    this.ctx.strokeStyle = '#FFF';
    this.ctx.beginPath();
    for (let i = 0; i < points.length; i += 2) {
      const n = (i + 2) % points.length;
      this.ctx.lineTo(points[i], points[i+1]);
      this.line(points[i], points[i+1], points[n], points[n+1]);
    }
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
  }
}

function basicEffect(ss) {
  const colors = Color('#000000').steps(256, '#FFFF00');
  for (let i = 0; i < colors.length; ++i) {
    const f = i / (colors.length - 1);
    colors[i] = colors[i].luminance(f ** 1.2)
      .saturate(2 * Math.abs(Math.sin(f * 7)))
      .rotate(-40 + 50 * (Math.cos(f * 5)))
      .multiply(Color('#FFFF0050'))
  }
  ss.colors = colors;
  ss.clear('#FFFFFF');
  ss.lineColor = '#3B2618';
  ss.maxTotalCracks = 12000;

  ss.begin({start: 3, random: 16});
}

function blueDiamond(ss) {
  const colors = Color('#000000').steps(256, '#00AAFF');
  for (let i = 0; i < colors.length; ++i) {
    const f = i / (colors.length - 1);
    colors[i] = colors[i].luminance((f * 0.9) ** 1.2)
      .saturate(4 * Math.abs(Math.sin(f * 7)))
      .multiply(Color('#FF00FF40'))
  }
  ss.colors = colors;
  ss.clear('#FFFFFF');
  ss.lineColor = '#323E51AA';
  ss.maxTotalCracks = 4000;
  ss.maxCracks = 64;

  ctx.strokeStyle = ss.lineColor;
  const m = new Mask();
  m.poly(960, 88, 1177, 273, 1177, 549, 1177, 825, 960, 993, 742, 825, 742, 549, 742, 273);
  ss.begin({mask: m});
}

function cube(ss) {
  ss.colors = null;
  ss.clear('#FFFFFF');
  ss.lineColor = ctx.strokeStyle = '#083648';
  ss.maxTotalCracks = 1000;

  const m = new Mask();
  m.poly(964,167, 1288,353, 964,545, 638,353);
  m.poly(1288,353, 1288,739, 964,923, 964,545);
  m.poly(638,353, 964,545, 964,923, 638, 739);
  ss.begin({mask: m, random: 16});
}

function area(ss) {
  ss.clear('#FFF');
  ss.maxTotalCracks = 4000;
  ss.maxCracks = 32;
  ss.lineColor = ctx.strokeStyle = '#083648';
  ss.angleVariance = 0;

  const colors = Color('#28C9FF').steps(64, '#E313AF');
  for (let i = 0; i < colors.length; ++i) {
    const f = i / (colors.length - 1);
    colors[i] = colors[i].luminance(Math.abs(Math.sin(f * 4)) * 0.65)
      .saturate(0.25 * Math.abs(Math.sin(f * 7)))
  }
  ss.colors = colors;

  const m = new Mask();
  const a = 50;
  const b = 200;

  m.poly(a + b, a,
    W - a, a,
    W - a, H - a - b,
    W - a - b, H - a,
    a, H - a,
    a, a + b);

  ss.begin({mask: m});
}

function bezier(ss) {
  ss.clear('#FFF');
  ss.maxTotalCracks = 4000;
  ss.maxCracks = 128;
  ss.lineColor = ctx.strokeStyle = '#000';
  ss.angleVariance = 0;
  ss.color = null;

  const m = new Mask();



  ss.begin({mask: m});
}

const ss = new Substrate();
// basicEffect(ss);
// blueDiamond(ss);
// cube(ss);
// area(ss);
bezier(ss);

function frame() {
  if (ss.update()) {
    requestAnimationFrame(frame);
  }
}
frame();
</script>
